
---
title: "Introduction to epidemia"
output:
  pdf_document: default
fontsize: 12pt
bibliography: ../inst/REFERENCES.bib
vignette: |
  %\VignetteIndexEntry{Introduction to epidemia} 
  %\VignetteEngine{knitr::rmarkdown} 
  \usepackage[utf8]{inputenc}
---

This vignette is very much a work in progress, and will be regularly updated. It aims to detail the models fit by epidemia, and also to demonstrate basic usage of the package. The main work is done in the `epim` function. Before continuing, please read the documentation for a more detailed description of this function.

## Model Overview

@Flaxman2020 introduced a hierarchical Bayesian approach for epidemic modeling, and applied it to assessing the effect of non-pharmaceutical interventions on the covid-19 pandemic in 11 European countries. *epidemia* is designed to fit models which are largely extensions of this approach. There are however important differences which will be emphasized as we go along. The model is first described as it applies to a single population. Extensions to multiple populations are considered in the subsequent section.

### A Single Population

Let $(t_0, \ldots, t_n)$ be a time index, representing the period over which to simulate the epidemic. The index $t_0$ is taken to be the first date at which infections are non-zero in the population. In what follows $t$ is an arbitrary integer satisfying $t_0 < t \leq t_n$.

The basic idea behind the model is that the observed quantities (daily deaths, incidence rates etc.) are a function of the latent infections in the population over time. These infections are in turn a function of the *time-varying reproduction number*. This number may be explained by a number of covariates; for example non-pharmaceutical interventions, or changes in mobility over time.

The remainder of this section is organized as follows. First, the model for the sequence of time-varying reproduction numbers is described. Infections are then modeled in terms of this sequence. Finally, the observed data is modeled as a function of these latent infections. 

#### Time-varying reproduction number 

Let $R := (R_{t_0},\ldots,R_{t_n})$ be a non-negative sequence representing the *unadjusted* time-varying reproduction number over the period considered.  Intuitively, $R_t$ measures the intensity of infectious interactions occuring in the population at time $t$. The term *unadjusted* is used to make explicit that the sequence being modeled has not been adjusted for the size of the susceptible population. This adjustment is made later in the model for infections. The sequence is parameterized as
$$
R = 2A f\left(X\beta + Zb\right)
$$
where $A$ is a constant, $X$ and $Z$ are $n \times p$ and $n \times q$ model matrices and where $f$ is the logistic function $f(a) := \exp(a)/(1+\exp(a))$. The $p$-dimensional $\beta$ represents pooled coefficients, while the $q$-dimensional $b$ represent group-specific effects. When both $p$ and $q$ are greather than zero, this is known as *partial pooling*.

The vector $R$ is latent and unobserved. The quantities we do observe are linked to $R$ through its effect on underlying infections, which we now describe.


#### Infections

Let $I_{t_0}, \ldots I_{t_n}$ be a sequence, wher $I_{t'}$ is the count of infections that have occurred by period ${t'}$,



Consider the sequence of cumulative infections $I_{t_0}, I_{t_0+1}, \ldots$. This is modeled as the *exact* solution to an ordinary differential equation. Before describing this ODE, first define $s := (s_1,s_2,\ldots)$, a distribution on $\mathbb{Z}^+$ representing the serial interval of the disease being modeled.

The ODE $I(t)$ satisfies 
$$
\frac{dI(t)}{dt} = \frac{P-I(t)}{P}R_{\lfloor t \rfloor}c_{\lfloor t \rfloor},
$$
where $c-t$ is a weighted sum over previous infections, defined by
$$
c_{t} = \sum_{\tau=1}^{t} (I_{\tau} - I_{\tau-1}) s_{t-\tau}.
$$

The exact solution to the above ODE on the integers is easily shown to give 
$$
I_t = I_{t-1} + (P - I_{t-1})\left( 1 -\exp\left(-\frac{R_tc_t}{P}\right)\right),
$$
where $P$ is the population size. This satisfies intuitive properties. If $R_t = 0$, then there are no new infections. Fixing $c_t > 0$ and letting $R_t \to \infty$ implies that $I_t \to P$, i.e. everyone is infected tomorrow.

#### Observations

Data is observed from $L$ observation processes $Y_{t}^{(1)}, \ldots Y_{t}^{(L)}$. Each process represents a different type of observation. This could be daily death data as used in @Flaxman2020, or hospitalization rates, or recorded infections for example. The random variables $Y^{(l)}_t$ are assumed to follow a negative binomial distribution with mean $y_{t}^{(l)}$ and variance
$$
y_t^{(l)} + \frac{{\left(y_t^{(l)}\right)}^2}{\phi_l},
$$
where $\phi_l \sim \mathcal{N}^+(0,\sigma^2_{\phi_l})$ for some hyperparameter $\sigma^2_{\phi_l} > 0$. The expected value $y_{t}^{(l)}$ is modeled as a function of
\begin{itemize}
\item $I_{t_0}, \ldots, I_{t-1}$, where $I_{t'}$ is the count of infections that have occurred by period ${t'}$,
\item $\pi^{(l)} = (\pi^{(l)}_1, \pi^{(l)}_2, \ldots)$, a discrete distribution on $\mathbb{Z}^+$ representing the time distribution from an infection event to an observation event,
\item and a proportion $\alpha_l$, assumed to be a time constant quantity representing the rate of infections which will eventually record as an observation of type $l$.
\end{itemize}
To give intuition on the above quantities, suppose for now that the $l$\textsuperscript{th} observation process recorded daily death counts. Then $\pi^{(l)}_{t'}$ is the probability, conditional on a death being recorded today, that this individual was infected exactly ${t'}$ days prior. $\alpha_{l}$ is then the mean infection fatality ratio (IFR) for the given population.

The functional form for $y_{t}^{(l)}$ is then simply
$$
y_{t}^{(l)} := \alpha_l \sum_{\tau=t_0}^{t-1} (I_{\tau} - I_{\tau-1})\pi^{(l)}_{t-\tau},
$$
where $I_{t_0-1} = 0$. The distribution $\pi^{(l)}$ is *treated as known*, however in future versions of epidemia we may allow it to be learnt. One possibility in this direction would be to view $\pi^{(l)}$ as a discretization of a continuous parametric distribution. The parameters could be given priors and learnt. The Gamma distribution is a suitable candidate for this.

The proportion $\alpha_l$ is treated as unknown, and given a normal prior truncated to the unit interval. To be precise
$$
\alpha_l \sim \mathcal{N}_{[0,1]}(\mu_l, \sigma^2_{\alpha_l}),
$$
for given hyperparameters $\mu_l$ and $\sigma^2_{\alpha_l}$. In future versions of epidemia, these proportions may instead be assigned Beta priors.


## Multiple Populations

TODO

## Example Usage

The main model fitting function in epidemia is `epim`. This section demonstrates basic usage of this function.

### Europe Covid

The package contains the dataset used in @Flaxman2020. This data pertains to covid-19 in 11 European countries. Load this with
```{r}
library(epidemia)
data("EuropeCovid")
options(mc.cores = parallel::detectCores())
```

`EuropeCovid` is a list containing much of the information required for `epim`. These fields are named as follows.

```{r}
names(EuropeCovid)
```
Each of these names correspond to an argument required for `epim`. The 'data' argument is a dataframe with columns referring to possible covariates for modelling the time-varying reproduction number. It contains one column which will specify the `groups` to be modelled, and an additional column giving the dates corresponding to the covariate data. Note that the covariates included here will not be used unless specified in the formula argument of `epim` -- more on this below.

```{r}
args <- EuropeCovid
data <- args$data
head(data)
```

The `obs` argument is itself a list of lists. Each element of which corresponds to a different type of observation. This could for example be death, incidence, or hospitalisation counts. Following @Flaxman2020, we only consider death counts here.

```{r}
deaths <- args$obs$deaths
names(deaths)
```

`epim` requires a formula, which specifies the model to be fit. In the current version of the package, the terms in the formila must correspond to the names in `data`. This may be relaxed in future versions, in line with other model fitting functions like `lm` or `glm`.

Although `data$country` contains 11 different populations, here we consider, for simplicity, only two. Specifically we will look at Germany and the United Kingdim. `epim` makes this simple by providing a `group_subset` argument.

```{r}
args$group_subset <- c("Germany", "United_Kingdom")
```

 A model is specified using the `formula` argument. The LHS of the formula always takes the form `R(x,y)` for some columns `x` and `y` in `data`. Unless `group_subset` is specified explicitly, `epim` will use the factor levels in `data$x` as the groups to model, and will use `data$y` to specify the modeled dates for each group. The dates must be a consecutive range, and there must be no missing covarite data in the columns specified on the RHS of the formula. The first date found for each group is assumed to be the beginning of the epidemic, and seeding of infections begins from this date.

We briefly give an intepretation of the models specified by different fomulas. Suppose for simplicity that the value of all covariates at the start date is zero, so that the intercept can be interpreted as specifying the $R_0$. Then

* `R(country, date) ~ 0 + ...` This is a no-intercept model. The effect is to set an exact starting $R_0$ which is the same for all countries. This is then modified at dates for which covariates become non-zero (i.e. after interventions come into place). This starting value is controlled by the `r0` argument to `epim`, which defaults to 3.28.

* `R(country, date) ~ 1 + ...` This gives a common intercept for all countries. The distribution for $R_0$ is the same for all countries. This distribution can be modified by specifying the `prior_intercept` argument for `epim`

* `R(country, date) ~ (1 | country) + ...` The random effects term allows the distribution for $R_0$ to depend on the country. The prior for these is controlled by both `prior_intercept` and `prior_covariance`.

Similar to @Flaxman2020, we specify the following model.

```{r}
args$formula <- R(country,date) ~ 1 + schools_universities + self_isolating_if_ill + public_events + lockdown + social_distancing_encouraged
```

This model allows a separate $R_0$ for each country, and includes 6 different non-pharamceutical interventions (NPIs) to explain the changes in the time-varying reproduction number.

### Trying out different priors.

The priors on the coefficient in the regressions, and on other parameters are controlled by the arguments `prior`, `prior_intercept`, `prior_covariance`, `prior_tau` and `prior_phi`. Please read the documentation for `epim` for a precise interpretation of these arguments.

Here we focus on specifying the `prior` argument. This controls the prior distribution of the coefficients in the regression. Any of the rstanarm priors can be used. We have also added a `shifted_gamma` prior to replicate the prior in @Flaxman2020.

To quickly visualise the effect of the prior distribution we can used the `prior_PD` flag to `epim`. If `TRUE` epim will sample all parameters from their prior distribution. We specify the prior for the intercept as follows.

```{r}
args$prior_intercept <- rstanarm::normal(location=0,scale = 0.5)
```

```{r, results = "hide"}
args$prior <- rstanarm::normal(scale = 0.5)
args$algorithm <- "sampling"
args$sampling_args <- list(iter=200,control=list(adapt_delta=0.95,max_treedepth=15))
args$prior_PD <- TRUE
fit <- do.call("epim", args)
plot_rt(fit, levels = c(20,40,60,80,95))
```

And example of using a shifted gamma prior...

```{r, results="hide"}
args$prior <- shifted_gamma(shape=1/6, scale=1, shift = -log(1.05)/6)
fit <- do.call("epim", args)
plot_rt(fit, levels = c(20,40,60,80,95))
```

Fitting the model to the data...
```{r, results="hide"}
args$prior_PD = FALSE
fit <- do.call("epim", args)
```

Printing the object gives a brief summary.

```{r}
print(fit, digits = 2)
```

Can extract the priors used...

```{r}
prior_summary(fit)
```

And get the matrix of parameter draws

```{r}
draws <- as.matrix(fit)
head(draws)
```



