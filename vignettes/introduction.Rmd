---
title: "Flexible Epdiemic Modeling with epidemia"
output:
  bookdown::html_document2:
fontsize: 12pt
fig_width: 9 
fig_height: 6
bibliography: ../inst/REFERENCES.bib
vignette: |
  %\VignetteIndexEntry{Introduction to epidemia} 
  %\VignetteEngine{knitr::rmarkdown} 
  \usepackage[utf8]{inputenc}
---

**Note:** *This vignette is very much a work in progress, and will be regularly updated.*

**epidemia** is an R-package for fitting Bayesian epidemic models in the style of @Flaxman2020. Here we detail these models and give users enough information to start fitting them independently.

The document is organized as follows. Section \@ref(example-usage) provides basic examples with minimal description, so that users can quickly get a feel for the package. Section \@ref(model-overview) digs deeper and gives a formal framework for the models within the scope of the package. Understanding this framework is essential for making the most of the flexibility offered by **epidemia**. Section \@ref(r-implementation) discusses the details of `epim`; the primary model fitting function in the package. `epim` is designed to be flexible, and therefore has a number of arguments. This can be intimidating, and so Section \@ref(r-implementation) describes these arguments in a lot of detail. Finally Section \@ref(examples) highlights some of the more useful features of the package.

The package contains an example dataset `EuropeCovid`, which contains data on the daily deaths from Covid-19 recorded in 11 European countries. This will be used as a running example throughout the vignette.

```{r message=FALSE}
library(epidemia)
library(xfun)
data("EuropeCovid")
options(mc.cores = parallel::detectCores())
```

The line `options(mc.cores = parallel::detectCores())` is important if MCMC sampling is used, as it allows different chains to be run in parallel, rather than sequentially.


# Example Usage
Here we provide code snippets showing basic usage of **epidemia**. Below considers fitting a model to the Italian data, and demonstrates usage of various arguments to `epim`.
```{r computeItaly,results='hide'}
# collect arguments for 'epim'
args <- EuropeCovid
args$algorithm <- "sampling"
args$sampling_args <- list(iter=600,control=list(adapt_delta=0.95,max_treedepth=15),seed=12345)
args$group_subset <- c("Italy")
args$formula <- R(country,date) ~  1 + lockdown
args$prior <- rstanarm::normal(location=0,scale=.5)
args$prior_intercept <- rstanarm::normal(location=0,scale=2)
fit <- xfun::cache_rds({do.call("epim", args)})
```
```{r plotItaly, fig.height=9, fig.align="center"}
library(gridExtra)
grid.arrange(plot_obs(fit, type="deaths"), plot_infections(fit), plot_rt(fit),nrow=3)
```

Often we would like to model more than one population. Here is an example of using multiple populations, where the regression for the time-varying reproduction number includes a country-specific intercept. This could also be extended to group specific sloups; for example by using `(1 | lockdown)` in the formula argument.

```{r computeIU,results='hide'}
# collect arguments for 'epim'
args$group_subset <- c("Italy", "United_Kingdom")
args$formula <- R(country,date) ~  (1|country) + lockdown
fit <- xfun::cache_rds({do.call("epim", args)})
```
```{r plotIU,results='hold',fig.align="center", fig.width=12}
plot_obs(fit, type = "deaths")
plot_rt(fit)
```

# Model Overview

@Flaxman2020 introduced a hierarchical Bayesian approach for epidemic modeling, and applied it to assessing the effect of non-pharmaceutical interventions on the covid-19 pandemic in 11 European countries. **epidemia** is designed to fit models which are largely extensions of this approach. There are however important differences which will be emphasized as we go along. The model is first described as it applies to a single population. Extensions to multiple populations are considered in the subsequent section.

## A Single Population

Let $t_0$ be an integer representing the first date at which infections are non-zero in the population, and let $T$ be the number of consecutive days over which to simulate the epidemic.

The basic idea behind the model is that the observed quantities (daily deaths, incidence rates etc.) are a function of the latent infections in the population over time. These infections are in turn a function of the *time-varying reproduction number*. This number may be explained by a number of covariates; for example non-pharmaceutical interventions, or changes in mobility over time.

The remainder of this section is organized as follows. First, the model for the sequence of time-varying reproduction numbers is described. Infections are then modeled in terms of this sequence. Finally, the observed data is modeled as a function of these latent infections. 

### Time-varying reproduction number 

Let $R := (R_{0},\ldots,R_{T})$ be a non-negative sequence representing the *unadjusted* time-varying reproduction number over the period considered.  Intuitively, $R_t$ measures the intensity of infectious interactions occuring in the population at time $t_0 + t$. The term *unadjusted* is used to make explicit that the sequence being modeled has not been adjusted for the size of the susceptible population. This adjustment is made later in the model for infections. The sequence is parameterized as
\begin{equation}
R = 2A f\left(X\beta + Zb\right)
(\#eq:rt)
\end{equation}
where $A$ is a constant, $X$ and $Z$ are $T \times p$ and $T \times q$ model matrices and where $f$ is the logistic function $f(a) := \exp(a)/(1+\exp(a))$. The $p$-dimensional $\beta$ represents pooled coefficients, while the $q$-dimensional $b$ represent group-specific effects. When both $p$ and $q$ are greater than zero, this is known as *partial pooling*.

The vector $R$ is latent and unobserved. The quantities we do observe are linked to $R$ through its effect on the underlying infections, which we now describe.


### Infections

Let $I_{0}, \ldots I_{T}$ be a sequence where $I_{t}$ is the count of infections that have occurred by date $t_0 + t$. This is modeled as the *exact* solution to an ordinary differential equation denoted by $I(t)$. Before describing this ODE, first define $s := (s_1,s_2,\ldots)$, a distribution on $\mathbb{Z}^+$ representing the serial interval of the disease being modeled.

The ODE $I(t)$ satisfies 
$$
I'(t) =  \left(\frac{P-I(t)}{P} \right)R_{\lfloor t \rfloor}c_{\lfloor t \rfloor},
$$
with initial condition $I(0)=0$ and where $c_t$ is a weighted summation over previous infections
$$
c_{t} = \sum_{\tau=1}^{t} (I(\tau) - I(\tau-1)) s_{t-\tau}.
$$

The exact solution to the above ODE at $t = 1, \ldots$ is easily shown to be 
$$
I_t = I_{t-1} + (P - I_{t-1})\left( 1 -\exp\left(-\frac{R_tc_t}{P}\right)\right),
$$
where $P$ is the population size. This satisfies intuitive properties. If $R_t = 0$, then there are no new infections. Fixing $c_t > 0$ and letting $R_t \to \infty$ implies that $I_t \to P$, i.e. everyone is infected tomorrow.

### Observations

Data is observed from $L$ observation processes $Y_t^{(1)} \ldots Y_{t}^{(L)}$, with the subscript $t$ ranging between $1$ and $T$. Each process represents a different type of observation. This could be daily death data as used in @Flaxman2020, or hospitalization rates, or recorded infections for example. The random variables $Y^{(l)}_t$ are assumed to follow a negative binomial distribution with mean $y_{t}^{(l)}$ and variance
$$
y_t^{(l)} + \frac{{\left(y_t^{(l)}\right)}^2}{\phi_l},
$$
where $\phi_l \sim \mathcal{N}^+(0,\sigma^2_{\phi_l})$ for some hyperparameter $\sigma^2_{\phi_l} > 0$. The expected value $y_{t}^{(l)}$ is modeled as a function of
\begin{itemize}
\item $I_{t_0}, \ldots, I_{t-1}$, where $I_{t'}$ is the count of infections that have occurred by period ${t'}$,
\item $\pi^{(l)} = (\pi^{(l)}_1, \pi^{(l)}_2, \ldots)$, a discrete distribution on $\mathbb{Z}^+$ representing the time distribution from an infection event to an observation event,
\item and a proportion $\alpha_l$, assumed to be a time constant quantity representing the rate of infections which will eventually record as an observation of type $l$.
\end{itemize}
To give intuition on the above quantities, suppose for now that the $l$\textsuperscript{th} observation process recorded daily death counts. Then $\pi^{(l)}_{t}$ is the probability, conditional on a death being recorded today, that this individual was infected exactly ${t}$ days prior. $\alpha_{l}$ is then the mean infection fatality ratio (IFR) for the given population.

The functional form for $y_{t}^{(l)}$ is then simply
$$
y_{t}^{(l)} := \alpha_l \sum_{\tau=1}^{t-1} (I_{\tau} - I_{\tau-1})\pi^{(l)}_{t-\tau}.
$$
The distribution $\pi^{(l)}$ is *treated as known*, however in future versions of epidemia we may allow it to be learnt. One possibility in this direction would be to view $\pi^{(l)}$ as a discretization of a continuous parametric distribution. The parameters could be given priors and learnt. The Gamma distribution is a suitable candidate for this.

The proportion $\alpha_l$ is treated as unknown, and given a normal prior truncated to the unit interval. To be precise
$$
\alpha_l \sim \mathcal{N}_{[0,1]}(\mu_l, \sigma^2_{\alpha_l}),
$$
for given hyperparameters $\mu_l$ and $\sigma^2_{\alpha_l}$. In future versions of epidemia, these proportions may instead be assigned Beta priors.


## Multiple Populations

Extending to multiple populations is straightforward. Suppose now that there are $M$ non-overlapping populations with differing start dates $t^{(m)}_0$ and epidemic lengths $T_m$. Collect the time-varying reproduction numbers into a vector $R$ with total length $T' := \sum_{m=1}^M T_m$, and consider the parameterization of $R$ in terms of covariates given in \@ref(eq:rt). This approach allows flexible pooling of parameters through $\beta$, while still permitting between group variation using the group-effects $b$. Some populations may have little data; these groups could be at the early stages of the epidemic for example. This approach allows learning to be shared between groups, while helping to avoid overfitting to each group.

# R Implementation

**epidemia** is designed to fit the models described in Section \@ref(model-overview). In particular, it uses R's formula interface to parameterize the time-varying reproduction number in terms of a number of covariates (see \@ref(eq:rt)). The implementation of this shares many similarities with the `stan_glmer` function in **rstanarm** and the **glmer** function in **lme4**.

## Model fitting using `epim`

As mentioned in the introduction, the primary model fitting function in **epidemia** is `epim`. We now describe this function in depth. Section \@ref(function-arguments) details the formal arguments to `epim`, and links them where possible to the mathematical notation used in Section \@ref(model-overview). Much of the intuition for these arguments will come only through examples, which are provided in Section \@ref(example-calls).

### Function Arguments

Table \@ref(tab:epimArgs) lists the formal arguments to `epim`.

```{r epimArgs, echo=F}
df <- data.frame(Arguments = c("formula", 
                               "data",
                               "obs",
                               "pops",
                               "si",
                               "seed_days",
                               "algorithm",
                               "group_subset",
                               "center",
                               "prior",
                               "prior_intercept",
                               "prior_covariance",
                               "r0",
                               "prior_phi",
                               "prior_tau",
                               "prior_PD",
                               "sampling_args"),
                 Description = c("The left hand side must take the form `R(group,date)`, with `group` representing a factor vector giving the group membership (i.e. country, state, age cohort). `date` must ve a vector of Date objects.",
                                 "The data used in the model specified by 'formula'. Each term in `formula` must have a corresponding column in `data`.",
                                 "All available observations and hyperparamters for the observation model. Each element of `obs` represents its own type of observation. More on this below.",
                                 "Population of each modeled group. The first column represents the group and the second giving the corresponding population.",
                                 "A vector representing the serial interval of the disease. This should be a simplex vector - i.e. all elements are non-negative and sum to one. The $n$^th^ element gives the probability an individual infects another $n$ days after disease onset.",
                                 "Number of days $N_0$ for which to seed infections at the start of the epidemic.",
                                 "The algorithm used to fit the model. Must be one of 'sampling', 'meanfield' or 'fullrank', which correspond to `rstan` sampling methods.",
                                 "An optional vector specifying a subset of groups to model. Elements should correspond to the group levels specified through the `data` argument.",
                                 "If `TRUE` then all covariates in \\@ref(eq:rt) are centered (shifted to have mean zero). WARNING: *the priors are then interpreted as priors on the centered covariates*. Defaults to `FALSE`.",
                                 " The prior on $\\beta$, excluding the possible intercept.`",
                                 "Prior on the intercept if one has been specified in `formula`.`",
                                 "Prior on the covariance matrix of the group-specific parameters $b$. Only used if the formula has at least one term of the form `(.|.)`.",
                                 "Set the constant $A$, introduced in \\@ref(eq:rt).",
                                 "Prior on the vector $(\\phi_1, \\ldots, \\phi_L)$.",
                                 "Prior on $\\tau$.",
                                 "Flag whether to sample from the prior distribution.",
                                 "An (optional) named list of parameters to pass to the rstan function used for model fitting, for example `rstan::sampling`."),
                 Class = c("formula",
                          "data.frame",
                          "list",
                          "data.frame",
                          "numeric",
                          "integer",
                          "character",
                          "character",
                          "logical",
                          "list",
                          "list",
                          "list",
                          "numeric",
                          "list",
                          "list",
                          "logical",
                          "list"))
knitr::kable(df, caption = "Formal arguments for the epim function", booktabs=TRUE)
```

Most of the arguments listed in Table \@ref(tab:epimArgs) are self-explanatory. However the first three  require further explanation. We tackle each of these in turn.

#### `formula` Argument

This specifies the model for the *unadjusted* time-varying reproduction number, given by \@ref(eq:rt). The LHS takes the form `R(group,date)`. This is just syntactic sugar to make explicit that the model is for the reproduction number for a given population and date.

The right hand side can include both pooled and unpooled coefficients. For more details on interpreting different formulas, please see [here](https://cran.r-project.org/web/packages/lme4/vignettes/lmer.pdf). 

We briefly give an intepretation for specific models in the context of the Europe data. First note that terms in the formula must correspond to column names in `data`, which are
```{r dataColnames}
colnames(EuropeCovid$data)
```
Suppose for simplicity that the value of all covariates at the start date of each group is zero, so that the intercept can be interpreted as determining the basic reproduction number of the disease. Then

* `R(country, date) ~ 0 + lockdown` This is a no-intercept model. The effect is to set an exact starting reproduction rate $R_0$ which is *the same for all countries*. This potentially changes at dates for which `lockdown` become non-zero (i.e. after the intervention come into place). The starting value is precisely $A$ defined in \@ref(eq:rt). 

* `R(country, date) ~ 1 + lockdown` The intercept is the same for all countries. This implies a common distribution for $R_0$, which is set by `prior_intercept`.

* `R(country, date) ~ (1 | country) + lockdown` A country-specific intercept allows $R_0$ to depend on the country. The prior on these is controlled by both `prior_intercept` and `prior_covariance`.

#### `data` argument

This argument provides any data specified by the formula. It must contain at least two columns which give the modeled populations and simulation dates. In the Europe example, the columns `country` and `date` serve this purpose. The `country` column must be coercible to class `factor`, and the levels of this column determine the possible populations to model. 
```{r}
data <- EuropeCovid$data
levels(data$country)
```
If specified, only the populations given in the `group_subset` argument are modeled. Otherwise, all levels are used.

The `dates` column must be coercible to a 'Date' vector. Dates must be consecutive for each modeled group. The first date is taken to be the start date $t_0$ of the epidemic in that population, and the final date is taken to be $t_T$. 
```{r}
agg <- function(x,f) aggregate(x$date, by=list(x$country), FUN=f)
setNames(cbind(agg(data, min),
               agg(data, max)[,2]),
         c("country", "start", "date"))
```
The start dates shown above are thirty days prior to the first date for which more than 10 cumulative deaths were observed in the given country. They are *not learnt by the model*, rather they are assumed and specified by the user.

#### `obs` argument

A list of lists giving available observations from the $L$ observation processes introduced in Section \@ref(observations), and hyperparameters for the observation model. The $l$^th^ element of `obs` must itself be a named list containing the following three elements.

* **odata**: A three column dataframe representing observations from the $l$^th^ observation process. The first column represents group membership and must be coercible to class factor. The second column indicates the observation date and must be coercible to class Date. The third column contain the actual data.

* **rates**: A named list specifying the prior for the proportion of infected individuals recorded as an observation. For example if recording deaths this would be some estimate of each groups infection fatality ratio (IFR). The priors are assumed normal. Contains:

    * **means**: A two column dataframe giving the hyperparameters $\alpha_{l,m}$, i.e. the estimated mean proportion of infected individuals recorded as an observation. First column represents the group, while the second the corresponding proportion.

    * **scale**: The standard deviation $\sigma_{\alpha_l}$ around the mean values. Default is 0.1.

* **pvec**: The probability vector $\pi_l$ described in Section \@ref(sec:observations).

The `EuropeCovid` data contains an example of the `obs` argument. It uses only one type of observation, death data, and so $L=1$ in this case, and of course `EuropeCovid$obs`must has length one.
```{r}
deaths <- EuropeCovid$obs$deaths
```

We can inspect the observed deaths as follows.
```{r odata}
head(deaths$odata)
```

It is also instructive to look at `$rates` component.
```{r rates}
deaths$rates
```
This shows the assumed values for the hyperparameters $\alpha_{l,m}$ and $\sigma_{\alpha_l}$ described above. Note the differing prior expected value of the IFR between groups. This is partially a result of differing age demographics.

Finally, we visualise the distribution of time from disease onset to death.
```{r pvec, fig.align="center"}
barplot(deaths$pvec, names.arg=1:101)
```

Following @Flaxman2020, this is a discretization of a $Gamma(X,Y)$ distribution.

### Example Calls

# Examples

The main model fitting function in **epidemia** is `epim`. This section demonstrates basic usage of this function.

## Europe Covid

The package contains the dataset used in @Flaxman2020. This data pertains to covid-19 in 11 European countries. Load this with

`EuropeCovid` is a list containing much of the information required for `epim`. These fields are named as follows.

```{r}
names(EuropeCovid)
```
Each of these names correspond to an argument required for `epim`. The 'data' argument is a dataframe with columns referring to possible covariates for modelling the time-varying reproduction number. It contains one column which will specify the `groups` to be modelled, and an additional column giving the dates corresponding to the covariate data. Note that the covariates included here will not be used unless specified in the formula argument of `epim` -- more on this below.

```{r}
args <- EuropeCovid
data <- args$data
head(data)
```

The `obs` argument is itself a list of lists. Each element of which corresponds to a different type of observation. This could for example be death, incidence, or hospitalisation counts. Following @Flaxman2020, we only consider death counts here.

```{r}
deaths <- args$obs$deaths
names(deaths)
```

`epim` requires a formula, which specifies the model to be fit. In the current version of the package, the terms in the formila must correspond to the names in `data`. This may be relaxed in future versions, in line with other model fitting functions like `lm` or `glm`.

Although `data$country` contains 11 different populations, here we consider, for simplicity, only two. Specifically we will look at Germany and the United Kingdim. `epim` makes this simple by providing a `group_subset` argument.

```{r}
args$group_subset <- c("Germany", "United_Kingdom")
```

 A model is specified using the `formula` argument. The LHS of the formula always takes the form `R(x,y)` for some columns `x` and `y` in `data`. Unless `group_subset` is specified explicitly, `epim` will use the factor levels in `data$x` as the groups to model, and will use `data$y` to specify the modeled dates for each group. The dates must be a consecutive range, and there must be no missing covarite data in the columns specified on the RHS of the formula. The first date found for each group is assumed to be the beginning of the epidemic, and seeding of infections begins from this date.

Similar to @Flaxman2020, we specify the following model.

```{r}
args$formula <- R(country,date) ~ 1 + schools_universities + self_isolating_if_ill + public_events + lockdown + social_distancing_encouraged
```

This model allows a separate $R_0$ for each country, and includes 6 different non-pharamceutical interventions (NPIs) to explain the changes in the time-varying reproduction number.

## Prior Specification

The priors on the coefficient in the regressions, and on other parameters are controlled by the arguments `prior`, `prior_intercept`, `prior_covariance`, `prior_tau` and `prior_phi`. Please read the documentation for `epim` for a precise interpretation of these arguments.

Here we focus on specifying the `prior` argument. This controls the prior distribution of the coefficients in the regression. Any of the rstanarm priors can be used. We have also added a `shifted_gamma` prior to replicate the prior in @Flaxman2020.

To quickly visualise the effect of the prior distribution we can used the `prior_PD` flag to `epim`. If `TRUE` epim will sample all parameters from their prior distribution. We specify the prior for the intercept as follows.

```{r}
args$prior_intercept <- rstanarm::normal(location=0,scale = 0.5)
```

\small
```{r normalPrior, results="hide"}
args$prior <- rstanarm::normal(scale = 0.5)
args$algorithm <- "sampling"
args$sampling_args <- list(iter=200,control=list(adapt_delta=0.95,max_treedepth=15))
args$prior_PD <- TRUE
fit <- xfun::cache_rds({do.call("epim", args)})
plot_rt(fit, levels = c(20,40,60,80,95))
```

\normalsize
And example of using a shifted gamma prior...

```{r gammaPrior, results="hide"}
args$prior <- shifted_gamma(shape=1/6, scale=1, shift = -log(1.05)/6)
fit <- xfun::cache_rds({ do.call("epim", args)})
plot_rt(fit, levels = c(20,40,60,80,95))
```

Fitting the model to the data...
```{r fittedRun, results="hide"}
args$prior_PD = FALSE
fit <- xfun::cache_rds({do.call("epim", args)})
```

Printing the object gives a brief summary.

```{r}
print(fit, digits = 2)
```

Can extract the priors used...

\small
```{r}
prior_summary(fit)
```

\normalsize
And get the matrix of parameter draws

\small
```{r}
draws <- as.matrix(fit)
draws[1:4,1:4]
```

\normalsize
# References
